<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Walkthrough · Stan</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Stan</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="INTRO.html">Introduction</a></li><li><a class="toctext" href="INSTALLATION.html">Installation</a></li><li class="current"><a class="toctext" href="WALKTHROUGH.html">Walkthrough</a><ul class="internal"><li><a class="toctext" href="#Bernoulli-example-1">Bernoulli example</a></li><li><a class="toctext" href="#Running-a-Stan-script,-some-details-1">Running a Stan script, some details</a></li></ul></li><li><a class="toctext" href="VERSIONS.html">Versions</a></li><li><a class="toctext" href="index.html">Stan.jl documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="WALKTHROUGH.html">Walkthrough</a></li></ul><a class="edit-page" href="https://github.com/goedman/Stan.jl/tree/9b05cbbdc4d6877ea02021c5af73f837c4ea4a0d/docs/src/WALKTHROUGH.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Walkthrough</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="A-walk-through-example-1" href="#A-walk-through-example-1">A walk-through example</a></h1><h2><a class="nav-anchor" id="Bernoulli-example-1" href="#Bernoulli-example-1">Bernoulli example</a></h2><p>In this walk-through, it is assumed that &#39;ProjDir&#39; holds a path to where transient files will be created (in a subdirectory /tmp of ProjDir).</p><p>Make Stan.jl and Mamba diagnostics and graphics available:</p><pre><code class="language-none">using Mamba, Stan</code></pre><p>Next define the variable &#39;bernoullistanmodel&#39; to hold the Stan model definition:</p><pre><code class="language-none">const bernoullistanmodel = &quot;
data { 
  int&lt;lower=0&gt; N; 
  int&lt;lower=0,upper=1&gt; y[N];
} 
parameters {
  real&lt;lower=0,upper=1&gt; theta;
} 
model {
  theta ~ beta(1,1);
    y ~ bernoulli(theta);
}
&quot;</code></pre><p>The next step is to create a Stanmodel object. The most common way to create such an object is by giving the model a name while the Stan model is passed in, both through keyword (hence optional) arguments:</p><pre><code class="language-none">stanmodel = Stanmodel(name=&quot;bernoulli&quot;, model=bernoullistanmodel);
stanmodel |&gt; display</code></pre><p>Above Stanmodel() call creates a default model for sampling. Other arguments to Stanmodel() can be found in <a href="index.html#Stan.Stanmodel"><code>Stanmodel</code></a></p><p>The observed input data is defined below.</p><pre><code class="language-none">const bernoullidata = Dict(&quot;N&quot; =&gt; 10, &quot;y&quot; =&gt; [0, 1, 0, 1, 0, 0, 0, 0, 0, 1])</code></pre><p>Run the simulation by calling stan(), passing in the data and the intended working directory. </p><pre><code class="language-none">rc, sim1 = stan(stanmodel, [bernoullidata], ProjDir, CmdStanDir=CMDSTAN_HOME)</code></pre><p>More documentation on stan() can be found in <a href="index.html#Stan.stan"><code>stan</code></a></p><p>If the return code rc indicated success (rc == 0), Mamba.jl provides the describe() function. We can&#39;t use all monitored variables by Stan. In this example a good subset is selected as below and stored in &#39;sim&#39;</p><pre><code class="language-none">if rc == 0
  sim1 = stan(stanmodel, [bernoullidata], ProjDir, CmdStanDir=CMDSTAN_HOME)
  println(&quot;Subset Sampler Output&quot;)
  sim = sim1[1:1000, [&quot;lp__&quot;, &quot;theta&quot;, &quot;accept_stat__&quot;], :]
  describe(sim)
end</code></pre><p>The first time (or when updates to the model have been made) stan() will compile the model and create the executable.</p><p>On Windows, the CmdStanDir argument appears needed (this is still being investigated). On OSX/Unix CmdStanDir is obtained from either ~/.juliarc.jl or an environment variable (see the Requirements section).</p><p>By default stan() will run 4 chains, optionally display a combined summary and returns a Mamba Chains object for a sampler. Some other Stan methods, e.g. optimize, return a dictionary.</p><p>The following diagnostics and Gadfly based plot functions (all from Mamba.jl) are available:</p><pre><code class="language-none">println(&quot;Brooks, Gelman and Rubin Convergence Diagnostic&quot;)
try
  gelmandiag(sim, mpsrf=true, transform=true) |&gt; display
catch e
  #println(e)
  gelmandiag(sim, mpsrf=false, transform=true) |&gt; display
end
println()

println(&quot;Geweke Convergence Diagnostic&quot;)
gewekediag(sim) |&gt; display
println()

println(&quot;Highest Posterior Density Intervals&quot;)
hpd(sim) |&gt; display
println()

println(&quot;Cross-Correlations&quot;)
cor(sim) |&gt; display
println()

println(&quot;Lag-Autocorrelations&quot;)
autocor(sim) |&gt; display
println()</code></pre><p>To plot the simulation results:</p><pre><code class="language-none">p = plot(sim, [:trace, :mean, :density, :autocor], legend=true);
draw(p, ncol=4, filename=&quot;summaryplot&quot;, fmt=:svg)
draw(p, ncol=4, filename=&quot;summaryplot&quot;, fmt=:pdf)</code></pre><h2><a class="nav-anchor" id="Running-a-Stan-script,-some-details-1" href="#Running-a-Stan-script,-some-details-1">Running a Stan script, some details</a></h2><p>Stan.jl really only consists of 2 functions, Stanmodel() and stan().</p><h3><a class="nav-anchor" id="[Stanmodel](@ref)-1" href="#[Stanmodel](@ref)-1"><a href="index.html#Stan.Stanmodel"><code>Stanmodel</code></a></a></h3><p>Stanmodel() is used to define the basic attributes for a model:</p><pre><code class="language-none">monitor = [&quot;theta&quot;, &quot;lp__&quot;, &quot;accept_stat__&quot;]
stanmodel = Stanmodel(name=&quot;bernoulli&quot;, model=bernoulli, monitors=monitor);
stanmodel</code></pre><p>Above script, in the Julia REPL, shows all parameters in the model, in this case (by default) a sample model.</p><p>Compared to the call to Stanmodel() above, the keyword argument monitors has been added. This means that after the simulation is complete, only the monitored variables will be read in from the .csv file produced by Stan. This can be useful if many, e.g. 100s, nodes are being observed.</p><pre><code class="language-none">stanmodel2 = Stanmodel(Sample(adapt=Adapt(delta=0.9)), name=&quot;bernoulli2&quot;, nchains=6)</code></pre><p>An example of updating default model values when creating a model. The format is slightly different from CmdStan, but the parameters are as described in the CmdStan Interface User&#39;s Guide. This is also the case for the Stanmodel() optional arguments random, init and output (refresh only).</p><p>Now, in the REPL, the stanmodel2 can be shown by:</p><pre><code class="language-none">stanmodel2</code></pre><p>After the Stanmodel object has been created fields can be updated, e.g.</p><pre><code class="language-none">stanmodel2.method.adapt.delta=0.85</code></pre><h3><a class="nav-anchor" id="[stan](@ref)-1" href="#[stan](@ref)-1"><a href="index.html#Stan.stan"><code>stan</code></a></a></h3><p>After a Stanmodel has been created, the workhorse function stan() is called to run the simulation. Note that some fields in the Stanmodel are updated by stan().</p><p>After the stan() call, the stanmodel.command contains an array of Cmd fields that contain the actual run commands for each chain. These are executed in parallel if that is possible. The call to stan() might update other info in the StanModel, e.g. the names of diagnostics files.</p><p>The stan() call uses &#39;make&#39; to create (or update when needed) an executable with the given model.name, e.g. bernoulli in the above example. If no model String (or of zero length) is found, a message will be shown.</p><footer><hr/><a class="previous" href="INSTALLATION.html"><span class="direction">Previous</span><span class="title">Installation</span></a><a class="next" href="VERSIONS.html"><span class="direction">Next</span><span class="title">Versions</span></a></footer></article></body></html>
